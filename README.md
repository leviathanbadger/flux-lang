# FluxLang: A Reactive, Verified Compiler Framework in Rust

FluxLang is an experimental programming language and compiler designed to unify reactive
dataflow programming and dependent/refinement type-theoretic verification into a single
cohesive framework. Implemented entirely in Rust, FluxLang pushes the envelope of
programming languages by offering:

## Note for Humans

This project is partially an experiment to see what OpenAI's Codex can do when given minimal instructions.
The README (and most all of the code) is generated by Codex, and I'm not sure how much of it will be technically correct.
FluxLang itself is not yet fully specified, so any code excerpts referenced in this repository should be treated as conceptual
pseudocode rather than actual, runnable programs.

## Project Overview

- **Goal:** Develop a prototype compiler for FluxLang that demonstrates novel language
  features and an extensible optimization pipeline.
- **Motivation:** Explore new frontiers in language design by combining temporal reactive
  types and proof-carrying code to enable safer, more expressive,
  and adaptive software.
- **Target Audience:** Programming language researchers, compiler engineers, systems
  programmers, and anyone intrigued by cutting-edge language design.

## Language Highlights

- **Temporal Type System:** First-class reactive streams with compile-time guarantees on
  event ordering and lifetime using linear and temporal types.
- **Refinement & Dependent Types:** Express rich invariants and use an embedded SMT solver
  (e.g., Z3) to discharge proof obligations, enabling proof-carrying code.
- **Hygienic Macro & Plugin Architecture:** Extend the compiler with custom compiler passes
  and DSL macros, all while preserving hygiene and type safety.

## Technology Stack

| Layer             | Technology/Crates                              | Notes                         |
| ----------------- | ----------------------------------------------- | ----------------------------- |
| Parser Gen        | lalrpop                                         | LALR(1) parser generator      |
| AST & Semantics   | Custom Rust enums & structs                     | Represent FluxLang AST        |
| Type Checker      | z3-sys / z3                                    | SMT for refinement checks     |
| IR & Optimizer    | inkwell, petgraph                               | LLVM IR & optimization graph  |
| JIT Backend       | cranelift                                       | Just-In-Time code generation  |
| LLVM Backend      | inkwell                                         | Native codegen pipeline       |
| WASM Backend      | wasm-bindgen                                    | Browser & Node.js targets     |
| CLI & Tooling     | clap, structopt                                 | Command-line interface        |
| Testing & LSP     | insta, tower-lsp                                 | Snapshot testing & IDE support|

## Objectives

- Solidify a formal language specification and core semantics for FluxLang.
- Build an end-to-end compiler pipeline from parsing to native and WASM code generation.
- Validate the type system and reactive invariants via SMT-backed proofs.
- Provide a modular framework for experimenting with new language and compiler features.

## Detailed Project Plan

For the complete roadmap and in-depth discussion of each phase, see
[PROJECT-PLAN.md](PROJECT-PLAN.md). The outline below summarizes the
high-level timeline.

### Phase 1: Language Specification (Weeks 1–4)
- Draft the formal grammar in EBNF and outline core syntactic constructs.
- Write a language report with motivating examples showcasing reactive streams and refinement types.
- Establish repository structure, coding guidelines, CI workflow, and contributor docs.

### Phase 2: Parser & AST Implementation (Weeks 5–8)
- Implement the FluxLang grammar using `lalrpop` and handle lexical analysis.
- Define AST data structures, source-location tracking, and basic pretty-printing.
- Create unit tests for parser coverage on core language features.

### Phase 3: Type Checking & Semantic Analysis (Weeks 9–16)
- Develop a bidirectional type checker for base types, dependent refinements, and temporal
  streams.
- Integrate Z3 via `z3-sys` to discharge refinement and temporal proof obligations.
- Design error reporting with precise diagnostics and suggestion hints.

### Phase 4: IR Design & Core Optimizations (Weeks 17–24)
- Design an intermediate representation capturing reactive graphs and effects.
- Build an optimization manager to run standard passes (constant folding, dead code
  elimination, temporal fusion).

### Phase 5: Backend Code Generation (Weeks 25–32)
- Implement an LLVM backend via `inkwell` for native executables.
- Add a WASM codegen path targeting WebAssembly and Node.js.
- Develop a Cranelift-based JIT for interactive REPL performance.

### Phase 6: Macro System & Plugin Framework (Weeks 33–36)
- Create a hygienic macro expander inspired by Rust’s macro system, extended for FluxLang AST.
- Define plugin APIs to register custom compiler passes, type transforms, and analysis tools.
- Build example plugins to demonstrate extensibility.

### Phase 7: Tooling, Testing & Documentation (Weeks 37–40)
- Develop `fluxc` CLI, REPL, and integrate an LSP server (`tower-lsp`).
- Write comprehensive tests (unit, integration, property-based) using `insta` and
  `quickcheck`.
- Prepare user guides, API docs, and tutorials in `docs/`.

### Phase 8: Research Experiments & Demos (Ongoing)
- Explore reactive UI demos.
- Benchmark performance against toy and real-world workloads.

### Future Directions
- GPU-targeted codegen for data-parallel streams.
- Quantum-inspired type extensions for safe qubit abstractions.
- Integration with proof assistants (Coq, Lean) for higher-assurance guarantees.
- Community workshops to gather feedback and foster contributions.

## License

FluxLang is released under the [MIT License](LICENSE).

---

*This project is purely academic and explores the frontier of programming language design.*
*Contributions, feedback, and wild ideas are strongly encouraged!*
